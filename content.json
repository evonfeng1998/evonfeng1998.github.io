{"meta":{"title":"EvonFeng's Blog","subtitle":"小锋的个人博客","description":"学无止境，头发也是","author":"EvonFeng","url":"http://evonFengBlog","root":"/"},"pages":[],"posts":[{"title":"Spring Boot Shiro用户认证","slug":"Spring-Boot-Shiro用户认证","date":"2019-12-08T06:25:16.000Z","updated":"2019-12-09T03:00:38.821Z","comments":true,"path":"2019/12/08/Spring-Boot-Shiro用户认证/","link":"","permalink":"http://evonfengblog/2019/12/08/Spring-Boot-Shiro%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/","excerpt":"","text":"Spring Boot Shiro用户认证在Spring Boot中集成Shiro进行用户的认证过程主要可以归纳为以下三点： 1、定义一个ShiroConfig，然后配置SecurityManager Bean，SecurityManager为Shiro的安全管理器，管理着所有Subject； 2、在ShiroConfig中配置ShiroFilterFactoryBean，其为Shiro过滤器工厂类，依赖于SecurityManager； 3、自定义Realm实现，Realm包含doGetAuthorizationInfo()和doGetAuthenticationInfo()方法，因为本文只涉及用户认证，所以只实现doGetAuthenticationInfo()方法。 核心API： Subject：用户主体 （把操作交给SecurityManager） SecurityManager：安全管理器（关联Realm） Realm：（Shiro连接数据的桥梁 引入依赖首先可根据文章《开启Spring Boot》搭建一个Spring Boot Web程序，然后引入Shiro、MyBatis、数据库和thymeleaf依赖： 1&lt;!-- MyBatis --&gt;2&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;3&lt;/dependency&gt;45 &lt;!-- thymeleaf --&gt;6&lt;dependency&gt;7&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;8&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;9 10 &lt;!-- shiro-spring --&gt;11&lt;dependency&gt; 12 &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; 13 &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;14 &lt;version&gt;1.4.0&lt;/version&gt;15&lt;/dependency&gt;1617&lt;!-- oracle驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; 18&lt;version&gt;6.0&lt;/version&gt;19&lt;/dependency&gt;2021&lt;!-- druid数据源驱动 --&gt;22 &lt;dependency&gt; 23 &lt;groupId&gt;com.alibaba&lt;/groupId&gt; 24 &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; 25 &lt;version&gt;1.1.6&lt;/version&gt;26 &lt;/dependency&gt; ShiroConfig定义一个Shiro配置类，名称为ShiroConfig： 1@Configuration2public class ShiroConfig &#123;3 @Bean4 public ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager) &#123;5 ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();6 // 设置securityManager7 shiroFilterFactoryBean.setSecurityManager(securityManager);8 // 登录的url9 shiroFilterFactoryBean.setLoginUrl(\"/login\");10 // 登录成功后跳转的url11 shiroFilterFactoryBean.setSuccessUrl(\"/index\");12 // 未授权url13 shiroFilterFactoryBean.setUnauthorizedUrl(\"/403\");14 15 LinkedHashMap&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();16 17 // 定义filterChain，静态资源不拦截18 filterChainDefinitionMap.put(\"/css/**\", \"anon\");19 filterChainDefinitionMap.put(\"/js/**\", \"anon\");20 filterChainDefinitionMap.put(\"/fonts/**\", \"anon\");21 filterChainDefinitionMap.put(\"/img/**\", \"anon\");22 // druid数据源监控页面不拦截23 filterChainDefinitionMap.put(\"/druid/**\", \"anon\");24 // 配置退出过滤器，其中具体的退出代码Shiro已经替我们实现了 25 filterChainDefinitionMap.put(\"/logout\", \"logout\");26 filterChainDefinitionMap.put(\"/\", \"anon\");27 // 除上以外所有url都必须认证通过才可以访问，未通过认证自动访问LoginUrl28 filterChainDefinitionMap.put(\"/**\", \"authc\");29 30 shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);31 return shiroFilterFactoryBean;32 &#125;33 34 @Bean 35 public SecurityManager securityManager()&#123; 36 // 配置SecurityManager，并注入shiroRealm37 DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();38 securityManager.setRealm(shiroRealm());39 return securityManager; 40 &#125; 41 42 @Bean 43 public ShiroRealm shiroRealm()&#123; 44 // 配置Realm，需自己实现45 ShiroRealm shiroRealm = new ShiroRealm(); 46 return shiroRealm; 47 &#125; 48&#125; 1/*Shiro内置过滤器，实现权限相关的拦截器2 * 常用过滤器：3 * anon: 无需认证（登录）就可以访问4 * authc: 必须认证才能访问5 * user: 如果使用rememberMe的功能可以直接访问6 * perms: 该资源必须得到资源权限才能访问7 * role: 该资源必须得到角色权限才能访问8*/ 需要注意的是filterChain基于短路机制，即最先匹配原则，如： 1&#x2F;user&#x2F;**&#x3D;anon2&#x2F;user&#x2F;aa&#x3D;authc 永远不会执行 其中anon、authc等为Shiro为我们实现的过滤器，具体如下表所示： Filter Name Class Description anon org.apache.shiro.web.filter.authc.AnonymousFilter 匿名拦截器，即不需要登录即可访问；一般用于静态资源过滤；示例/static/**=anon authc org.apache.shiro.web.filter.authc.FormAuthenticationFilter 基于表单的拦截器；如/**=authc，如果没有登录会跳到相应的登录页面登录 authcBasic org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter Basic HTTP身份验证拦截器 logout org.apache.shiro.web.filter.authc.LogoutFilter 退出拦截器，主要属性：redirectUrl：退出成功后重定向的地址（/），示例/logout=logout noSessionCreation org.apache.shiro.web.filter.session.NoSessionCreationFilter 不创建会话拦截器，调用subject.getSession(false)不会有什么问题，但是如果subject.getSession(true)将抛出DisabledSessionException异常 perms org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter 权限授权拦截器，验证用户是否拥有所有权限；属性和roles一样；示例/user/**=perms[&quot;user:create&quot;] port org.apache.shiro.web.filter.authz.PortFilter 端口拦截器，主要属性port(80)：可以通过的端口；示例/test= port[80]，如果用户访问该页面是非80，将自动将请求端口改为80并重定向到该80端口，其他路径/参数等都一样 rest org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter rest风格拦截器，自动根据请求方法构建权限字符串；示例/users=rest[user]，会自动拼出user:read,user:create,user:update,user:delete权限字符串进行权限匹配（所有都得匹配，isPermittedAll） roles org.apache.shiro.web.filter.authz.RolesAuthorizationFilter 角色授权拦截器，验证用户是否拥有所有角色；示例/admin/**=roles[admin] ssl org.apache.shiro.web.filter.authz.SslFilter SSL拦截器，只有请求协议是https才能通过；否则自动跳转会https端口443；其他和port拦截器一样； user org.apache.shiro.web.filter.authc.UserFilter 用户拦截器，用户已经身份验证/记住我登录的都可；示例/**=user 配置完ShiroConfig后，接下来对Realm进行实现，然后注入到SecurityManager中。 Realm自定义Realm实现只需继承AuthorizingRealm类，然后实现doGetAuthorizationInfo()和doGetAuthenticationInfo()方法即可。这两个方法名乍看有点像，authorization发音[ˌɔ:θəraɪˈzeɪʃn]，为授权，批准的意思，即获取用户的角色和权限等信息；authentication发音[ɔ:ˌθentɪ’keɪʃn]，认证，身份验证的意思，即登录时验证用户的合法性，比如验证用户名和密码。 1public class ShiroRealm extends AuthorizingRealm &#123;23 @Autowired4 private UserMapper userMapper;5 6 /**7 * 获取用户角色和权限8 */9 @Override10 protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principal) &#123;11 return null;12 &#125;1314 /**15 * 登录认证16 */17 @Override18 protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;1920 // 获取用户输入的用户名和密码21 String userName = (String) token.getPrincipal();22 String password = new String((char[]) token.getCredentials());23 24 System.out.println(\"用户\" + userName + \"认证-----ShiroRealm.doGetAuthenticationInfo\");2526 // 通过用户名到数据库查询用户信息27 User user = userMapper.findByUserName(userName);28 29 if (user == null) &#123;30 throw new UnknownAccountException(\"用户名或密码错误！\");31 &#125;32 if (!password.equals(user.getPassword())) &#123;33 throw new IncorrectCredentialsException(\"用户名或密码错误！\");34 &#125;35 if (user.getStatus().equals(\"0\")) &#123;36 throw new LockedAccountException(\"账号已被锁定,请联系管理员！\");37 &#125;38 SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user, password, getName());39 return info;40 &#125;41&#125; 因为本节只讲述用户认证，所以doGetAuthorizationInfo()方法先不进行实现。 其中UnknownAccountException等异常为Shiro自带异常，Shiro具有丰富的运行时AuthenticationException层次结构，可以准确指出尝试失败的原因。你可以包装在一个try/catch块，并捕捉任何你希望的异常，并作出相应的反应。例如： 12 虽然我们可以准确的获取异常信息，并根据这些信息给用户提示具体错误，但最安全的做法是在登录失败时仅向用户显示通用错误提示信息，例如“用户名或密码错误”。这样可以防止数据库被恶意扫描。 在Realm中UserMapper为Dao层，标准的做法应该还有Service层，但这里为了方便就不再定义Service层了。接下来编写和数据库打交道的Dao层。 数据层首先创建一张用户表，用于存储用户的基本信息（基于Oracle 11g）： 1-- ----------------------------2-- Table structure for T_USER3-- ----------------------------4CREATE TABLE &quot;SCOTT&quot;.&quot;T_USER&quot; (5 &quot;ID&quot; NUMBER NOT NULL ,6 &quot;USERNAME&quot; VARCHAR2(20 BYTE) NOT NULL ,7 &quot;PASSWD&quot; VARCHAR2(128 BYTE) NOT NULL ,8 &quot;CREATE_TIME&quot; DATE NULL ,9 &quot;STATUS&quot; CHAR(1 BYTE) NOT NULL 10);1112COMMENT ON COLUMN &quot;SCOTT&quot;.&quot;T_USER&quot;.&quot;USERNAME&quot; IS &#39;用户名&#39;;13COMMENT ON COLUMN &quot;SCOTT&quot;.&quot;T_USER&quot;.&quot;PASSWD&quot; IS &#39;密码&#39;;14COMMENT ON COLUMN &quot;SCOTT&quot;.&quot;T_USER&quot;.&quot;CREATE_TIME&quot; IS &#39;创建时间&#39;;15COMMENT ON COLUMN &quot;SCOTT&quot;.&quot;T_USER&quot;.&quot;STATUS&quot; IS &#39;是否有效 1：有效 0：锁定&#39;;1617-- ----------------------------18-- Records of T_USER19-- ----------------------------20INSERT INTO &quot;SCOTT&quot;.&quot;T_USER&quot; VALUES (&#39;2&#39;, &#39;test&#39;, &#39;7a38c13ec5e9310aed731de58bbc4214&#39;, TO_DATE(&#39;2017-11-19 17:20:21&#39;, &#39;YYYY-MM-DD HH24:MI:SS&#39;), &#39;0&#39;);21INSERT INTO &quot;SCOTT&quot;.&quot;T_USER&quot; VALUES (&#39;1&#39;, &#39;mrbird&#39;, &#39;42ee25d1e43e9f57119a00d0a39e5250&#39;, TO_DATE(&#39;2017-11-19 10:52:48&#39;, &#39;YYYY-MM-DD HH24:MI:SS&#39;), &#39;1&#39;);2223-- ----------------------------24-- Primary Key structure for table T_USER25-- ----------------------------26ALTER TABLE &quot;SCOTT&quot;.&quot;T_USER&quot; ADD PRIMARY KEY (&quot;ID&quot;); 数据源的配置这里就不贴出来了，具体可参考源码，或者参考https://mrbird.cc/Spring-Boot%E4%B8%AD%E4%BD%BF%E7%94%A8Mybatis.html。 库表对应的实体类： 1public class User implements Serializable&#123;23 private static final long serialVersionUID &#x3D; -5440372534300871944L;4 5 private Integer id;6 private String userName;7 private String password;8 private Date createTime;9 private String status;10 11 &#x2F;&#x2F; get,set略12&#125; 定义接口UserMapper： 1@Mapper2public interface UserMapper &#123;3 User findByUserName(String userName);4&#125; xml实现： 1&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;2&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;3&lt;mapper namespace&#x3D;&quot;com.springboot.dao.UserMapper&quot;&gt;4 &lt;resultMap type&#x3D;&quot;com.springboot.pojo.User&quot; id&#x3D;&quot;User&quot;&gt;5 &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot; javaType&#x3D;&quot;java.lang.Integer&quot; jdbcType&#x3D;&quot;NUMERIC&quot;&#x2F;&gt;6 &lt;id column&#x3D;&quot;username&quot; property&#x3D;&quot;userName&quot; javaType&#x3D;&quot;java.lang.String&quot; jdbcType&#x3D;&quot;VARCHAR&quot;&#x2F;&gt;7 &lt;id column&#x3D;&quot;passwd&quot; property&#x3D;&quot;password&quot; javaType&#x3D;&quot;java.lang.String&quot; jdbcType&#x3D;&quot;VARCHAR&quot;&#x2F;&gt;8 &lt;id column&#x3D;&quot;create_time&quot; property&#x3D;&quot;createTime&quot; javaType&#x3D;&quot;java.util.Date&quot; jdbcType&#x3D;&quot;DATE&quot;&#x2F;&gt;9 &lt;id column&#x3D;&quot;status&quot; property&#x3D;&quot;status&quot; javaType&#x3D;&quot;java.lang.String&quot; jdbcType&#x3D;&quot;VARCHAR&quot;&#x2F;&gt;10 &lt;&#x2F;resultMap&gt;11 &lt;select id&#x3D;&quot;findByUserName&quot; resultMap&#x3D;&quot;User&quot;&gt;12 select * from t_user where username &#x3D; #&#123;userName&#125;13 &lt;&#x2F;select&gt;14&lt;&#x2F;mapper&gt; 数据层准备完了，接下来编写login.html和index.html页面。 页面准备编写登录页面login.html： 1&lt;!DOCTYPE html&gt;2&lt;html xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;3&lt;head&gt;4 &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;5 &lt;title&gt;登录&lt;&#x2F;title&gt;6 &lt;link rel&#x3D;&quot;stylesheet&quot; th:href&#x3D;&quot;@&#123;&#x2F;css&#x2F;login.css&#125;&quot; type&#x3D;&quot;text&#x2F;css&quot;&gt;7 &lt;script th:src&#x3D;&quot;@&#123;&#x2F;js&#x2F;jquery-1.11.1.min.js&#125;&quot;&gt;&lt;&#x2F;script&gt;8&lt;&#x2F;head&gt;9&lt;body&gt;10 &lt;div class&#x3D;&quot;login-page&quot;&gt;11 &lt;div class&#x3D;&quot;form&quot;&gt;12 &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;用户名&quot; name&#x3D;&quot;username&quot; required&#x3D;&quot;required&quot;&#x2F;&gt;13 &lt;input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;密码&quot; name&#x3D;&quot;password&quot; required&#x3D;&quot;required&quot;&#x2F;&gt;14 &lt;button onclick&#x3D;&quot;login()&quot;&gt;登录&lt;&#x2F;button&gt;15 &lt;&#x2F;div&gt;16 &lt;&#x2F;div&gt;17&lt;&#x2F;body&gt;18&lt;script th:inline&#x3D;&quot;javascript&quot;&gt; 19 var ctx &#x3D; [[@&#123;&#x2F;&#125;]];20 function login() &#123;21 var username &#x3D; $(&quot;input[name&#x3D;&#39;username&#39;]&quot;).val();22 var password &#x3D; $(&quot;input[name&#x3D;&#39;password&#39;]&quot;).val();23 $.ajax(&#123;24 type: &quot;post&quot;,25 url: ctx + &quot;login&quot;,26 data: &#123;&quot;username&quot;: username,&quot;password&quot;: password&#125;,27 dataType: &quot;json&quot;,28 success: function (r) &#123;29 if (r.code &#x3D;&#x3D; 0) &#123;30 location.href &#x3D; ctx + &#39;index&#39;;31 &#125; else &#123;32 alert(r.msg);33 &#125;34 &#125;35 &#125;);36 &#125;37&lt;&#x2F;script&gt;38&lt;&#x2F;html&gt; 主页index.html： 1&lt;!DOCTYPE html&gt;2&lt;html xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;3&lt;head&gt;4 &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;5 &lt;title&gt;首页&lt;&#x2F;title&gt;6&lt;&#x2F;head&gt;7&lt;body&gt;8 &lt;p&gt;你好！[[$&#123;user.userName&#125;]]&lt;&#x2F;p&gt;9 &lt;a th:href&#x3D;&quot;@&#123;&#x2F;logout&#125;&quot;&gt;注销&lt;&#x2F;a&gt;10&lt;&#x2F;body&gt;11&lt;&#x2F;html&gt; 页面准备完毕，接下来编写LoginController。 ControllerLoginController代码如下： 1@Controller2public class LoginController &#123;34 @GetMapping(&quot;&#x2F;login&quot;)5 public String login() &#123;6 return &quot;login&quot;;7 &#125;89 @PostMapping(&quot;&#x2F;login&quot;)10 @ResponseBody11 public ResponseBo login(String username, String password) &#123;12 &#x2F;&#x2F; 密码MD5加密13 password &#x3D; MD5Utils.encrypt(username, password);14 UsernamePasswordToken token &#x3D; new UsernamePasswordToken(username, password);15 &#x2F;&#x2F; 获取Subject对象16 Subject subject &#x3D; SecurityUtils.getSubject();17 try &#123;18 subject.login(token);19 return ResponseBo.ok();20 &#125; catch (UnknownAccountException e) &#123;21 return ResponseBo.error(e.getMessage());22 &#125; catch (IncorrectCredentialsException e) &#123;23 return ResponseBo.error(e.getMessage());24 &#125; catch (LockedAccountException e) &#123;25 return ResponseBo.error(e.getMessage());26 &#125; catch (AuthenticationException e) &#123;27 return ResponseBo.error(&quot;认证失败！&quot;);28 &#125;29 &#125;3031 @RequestMapping(&quot;&#x2F;&quot;)32 public String redirectIndex() &#123;33 return &quot;redirect:&#x2F;index&quot;;34 &#125;3536 @RequestMapping(&quot;&#x2F;index&quot;)37 public String index(Model model) &#123;38 &#x2F;&#x2F; 登录成后，即可通过Subject获取登录的用户信息39 User user &#x3D; (User) SecurityUtils.getSubject().getPrincipal();40 model.addAttribute(&quot;user&quot;, user);41 return &quot;index&quot;;42 &#125;43&#125; 登录成功后，根据之前在ShiroConfig中的配置shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;)，页面会自动访问/index路径。 测试最终项目目录如下图所示： QQ截图20171213095352.png 启动项目，分别访问： http://localhost:8080/web/ http://localhost:8080/web/index http://localhost:8080/web/aaaaaaa http://localhost:8080/web 可发现页面都被重定向到http://localhost:8080/web/login： QQ截图20171213095706.png 当输入错误的用户信息时： QQ截图20171213095803.png 用test的账户登录（test账户的status为0，已被锁定）： QQ截图20171213095938.png 当输入正确的用户名密码时候： QQ截图20171213100035.png 点击注销连接，根据ShiroConfig的配置filterChainDefinitionMap.put(&quot;/logout&quot;, &quot;logout&quot;)，Shiro会自动帮我们注销用户信息，并重定向到/路径。 原文链接：[https://mrbird.cc/Spring-Boot-shiro%20Authentication.html](https://mrbird.cc/Spring-Boot-shiro Authentication.html)","categories":[],"tags":[{"name":"SpringBoot, shiro, Authentication","slug":"SpringBoot-shiro-Authentication","permalink":"http://evonfengblog/tags/SpringBoot-shiro-Authentication/"}]},{"title":"springboot","slug":"test","date":"2019-12-02T10:10:17.107Z","updated":"2019-12-02T10:58:32.961Z","comments":true,"path":"2019/12/02/test/","link":"","permalink":"http://evonfengblog/2019/12/02/test/","excerpt":"","text":"SpringBoot简介1.1 原有Spring优缺点分析1.1.1 Spring的优点分析Spring是Java企业版（Java Enterprise Edition，JEE，也称J2EE）的轻量级代替品。⽆需开发重量级的 Enterprise JavaBean（EJB），Spring为企业级Java开发提供了⼀种相对简单的⽅法，通过依赖注⼊和 ⾯向切⾯编程，⽤简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能。 1.1.2 Spring的缺点分析虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。⼀开始，Spring⽤XML配置，⽽且是很 多XML配置。Spring 2.5引⼊了基于注解的组件扫描，这消除了⼤量针对应⽤程序⾃身组件的显式XML 配置。Spring 3.0引⼊了基于Java的配置，这是⼀种类型安全的可重构配置⽅式，可以代替XML。 所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进⾏思维切 换，所以编写配置挤占了编写应⽤程序逻辑的时间。和所有框架⼀样，Spring实⽤，但与此同时它要求 的回报也不少。 除此之外，项⽬的依赖管理也是⼀件耗时耗⼒的事情。在环境搭建时，需要分析要导⼊哪些库的坐标， ⽽且还需要分析导⼊与之有依赖关系的其他库的坐标，⼀旦选错了依赖的版本，随之⽽来的不兼容问题 就会严重阻碍项⽬的开发进度。 1.2 SpringBoot的概述1.2.1 SpringBoot解决上述Spring的缺点SpringBoot对上述Spring的缺点进⾏的改善和优化，基于约定优于配置的思想，可以让开发⼈员不必在 配置与逻辑业务之间进⾏思维的切换，全身⼼的投⼊到逻辑业务的代码编写中，从⽽⼤⼤提⾼了开发的 效率，⼀定程度上缩短了项⽬周期。 1.2.2 SpringBoot的特点 为基于Spring的开发提供更快的⼊⻔体验 开箱即⽤，没有代码⽣成，也⽆需XML配置。同时也可以修改默认值来满⾜特定的需求 提供了⼀些⼤型项⽬中常⻅的⾮功能性特性，如嵌⼊式服务器、安全、指标，健康检测、外部配置 等 SpringBoot不是对Spring功能上的增强，⽽是提供了⼀种快速使⽤Spring的⽅式 1.2.3 SpringBoot的核⼼功能 起步依赖 起步依赖本质上是⼀个Maven项⽬对象模型（Project Object Model，POM），定义了对其他库 的传递依赖，这些东⻄加在⼀起即⽀持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到⼀起，并提供⼀些默认的功能。 自动配置 Spring Boot的⾃动配置是⼀个运⾏时（更准确地说，是应⽤程序启动时）的过程，考虑了众多因 素，才决定Spring配置应该⽤哪个，不该⽤哪个。该过程是Spring⾃动完成的。","categories":[],"tags":[]}]}